# Codefin, or the fine art of knowing what to do and when and why

https://craft-conf.com/speaker/GezaMihala

## Cynefin primer

- It's a thing for decision making.
- Scene: Lost in the dark about how to proceed with your task
- Cynefin calls this the state of *disorder*, and it's the default state
  with no observable constraints.
- As you start out, you get to the *chaotic* state
  - Act, sense, respond. Just do something, no point in planning.
- You move on to *complex* state, you enable contraints as understanding grows
  - Probe, sense, respond
- Then you get in the zone. That's the *complicated* state.
  - Sense, analyze, respond. You don't need to experiment anymore.
- Next, the *obvious* domain
  - Sense, categorise, respond.
    You don't even analyze anymore, you just get it done.
- Check how the states are charted normally.
  They're not really ordered
  and transitions between states are all over the place.
- With other words
  - chaotic is unknowable, forming, self-organizing, intuiting, WTF
  - complex is unknown, storming, flatly organized, interpreting, SMH
  - complicated is knowable, performing, hierarchy, integrating, GTD
  - obvious is known. norming, bureaucracy, institutionalizing, RTFM
- Checking the chart, the west side is more startuppy.
  Research, retrospection, objectives, emergence, etc.
- The east side has stability, consitency, tasks, and planning.

## This in software engineering

Progressions are noted with arrows in the domain-order from above.

- The fun and sustainable parts are on the north
- **Way of working**: mob programming -> pair programming
  -> code reviews -> headphones
- **Goals**: get out of chaotic -> actually ship
  -> incremental development -> process Jira tickets
- **Architecture**: Unborn -> emerging
  -> evolving -> like a straitjacket
- **Base**: Stack Overflow -> library
  -> framework -> prison
- **Codebase**: mess -> refactor towards pattern (as you recognize them)
  -> design with pattern -> get trapped in pattern
- **Languages**: bash -> Ruby
  -> Java -> Excel
- **Or**: scripting -> dynamic/weak typing
  -> static/strong typing -> code generation
- **Testing**: test last or not at all -> TDD as a design method
  -> test first -> test while
- You will loop a lot between complex and complicated
- You should try to avoid falling down to the south
- Check out codefin.org
